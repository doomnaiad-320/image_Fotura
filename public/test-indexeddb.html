<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IndexedDB æµ‹è¯•</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
      background: #1a1a1a;
      color: #fff;
    }
    button {
      background: #f97316;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      margin: 5px;
      font-size: 14px;
    }
    button:hover {
      background: #ea580c;
    }
    #log {
      background: #000;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
    }
    .log-entry {
      margin: 3px 0;
      padding: 2px 0;
    }
    .success { color: #10b981; }
    .error { color: #ef4444; }
    .info { color: #60a5fa; }
    h1 { color: #f97316; }
    .status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      margin-left: 10px;
    }
    .status.ok { background: #10b981; }
    .status.fail { background: #ef4444; }
  </style>
</head>
<body>
  <h1>ğŸ” IndexedDB åŠŸèƒ½æµ‹è¯•</h1>
  
  <div>
    <button onclick="testBasicSupport()">1. æµ‹è¯•æµè§ˆå™¨æ”¯æŒ</button>
    <button onclick="testDatabaseCreation()">2. æµ‹è¯•æ•°æ®åº“åˆ›å»º</button>
    <button onclick="testImageSave()">3. æµ‹è¯•ä¿å­˜å›¾ç‰‡</button>
    <button onclick="testImageRead()">4. æµ‹è¯•è¯»å–å›¾ç‰‡</button>
    <button onclick="clearDatabase()">æ¸…ç©ºæ•°æ®åº“</button>
    <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
  </div>

  <div id="log"></div>

  <script>
    const DB_NAME = 'aigc-studio-local';
    const DB_VERSION = 1;
    
    function log(message, type = 'info') {
      const logDiv = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(message);
    }

    function clearLog() {
      document.getElementById('log').innerHTML = '';
    }

    // æµ‹è¯• 1: æµè§ˆå™¨æ”¯æŒ
    function testBasicSupport() {
      log('=== æµ‹è¯• 1: æµè§ˆå™¨æ”¯æŒ ===', 'info');
      
      if (!window.indexedDB) {
        log('âŒ æµè§ˆå™¨ä¸æ”¯æŒ IndexedDB', 'error');
        return;
      }
      
      log('âœ… æµè§ˆå™¨æ”¯æŒ IndexedDB', 'success');
      log(`   ç‰ˆæœ¬: ${indexedDB.constructor.name}`, 'info');
    }

    // æµ‹è¯• 2: æ•°æ®åº“åˆ›å»º
    function testDatabaseCreation() {
      log('=== æµ‹è¯• 2: æ•°æ®åº“åˆ›å»º ===', 'info');
      
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      
      request.onerror = (e) => {
        log(`âŒ æ•°æ®åº“æ‰“å¼€å¤±è´¥: ${e.target.error}`, 'error');
      };
      
      request.onsuccess = (e) => {
        const db = e.target.result;
        log('âœ… æ•°æ®åº“æ‰“å¼€æˆåŠŸ', 'success');
        log(`   æ•°æ®åº“å: ${db.name}`, 'info');
        log(`   ç‰ˆæœ¬: ${db.version}`, 'info');
        
        const stores = Array.from(db.objectStoreNames);
        log(`   å¯¹è±¡ä»“åº“: ${stores.join(', ')}`, 'info');
        
        // æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
        if (stores.includes('images') && stores.includes('history')) {
          log('âœ… images å’Œ history è¡¨éƒ½å­˜åœ¨', 'success');
        } else {
          log(`âš ï¸ ç¼ºå°‘è¡¨: ${stores.includes('images') ? '' : 'images'} ${stores.includes('history') ? '' : 'history'}`, 'error');
        }
        
        db.close();
      };
      
      request.onupgradeneeded = (e) => {
        log('âš ï¸ æ•°æ®åº“éœ€è¦å‡çº§ (é¦–æ¬¡åˆ›å»º)', 'info');
        const db = e.target.result;
        
        // åˆ›å»º images è¡¨
        if (!db.objectStoreNames.contains('images')) {
          const imagesStore = db.createObjectStore('images', { keyPath: 'id' });
          imagesStore.createIndex('createdAt', 'createdAt', { unique: false });
          log('   åˆ›å»º images è¡¨', 'info');
        }
        
        // åˆ›å»º history è¡¨
        if (!db.objectStoreNames.contains('history')) {
          const historyStore = db.createObjectStore('history', { keyPath: 'id' });
          historyStore.createIndex('timestamp', 'timestamp', { unique: false });
          historyStore.createIndex('imageId', 'imageId', { unique: false });
          log('   åˆ›å»º history è¡¨', 'info');
        }
      };
    }

    // æµ‹è¯• 3: ä¿å­˜å›¾ç‰‡
    async function testImageSave() {
      log('=== æµ‹è¯• 3: ä¿å­˜å›¾ç‰‡ ===', 'info');
      
      try {
        // åˆ›å»ºä¸€ä¸ªæµ‹è¯•å›¾ç‰‡ (1x1 çº¢è‰²åƒç´ )
        const canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'red';
        ctx.fillRect(0, 0, 1, 1);
        
        const blob = await new Promise(resolve => canvas.toBlob(resolve));
        log(`   åˆ›å»ºæµ‹è¯•å›¾ç‰‡: ${blob.size} bytes`, 'info');
        
        // æ‰“å¼€æ•°æ®åº“
        const db = await openDatabase();
        
        // ä¿å­˜å›¾ç‰‡
        const imageId = `test-img-${Date.now()}`;
        const imageData = {
          id: imageId,
          blob: blob,
          mimeType: 'image/png',
          size: blob.size,
          createdAt: Date.now()
        };
        
        const transaction = db.transaction(['images'], 'readwrite');
        const store = transaction.objectStore('images');
        const request = store.add(imageData);
        
        request.onsuccess = () => {
          log(`âœ… å›¾ç‰‡ä¿å­˜æˆåŠŸ! ID: ${imageId}`, 'success');
          
          // åŒæ—¶ä¿å­˜å†å²è®°å½•
          const historyData = {
            id: `test-hist-${Date.now()}`,
            imageId: imageId,
            prompt: 'æµ‹è¯•æç¤ºè¯',
            timestamp: Date.now(),
            shared: false,
            favorite: false
          };
          
          const historyTx = db.transaction(['history'], 'readwrite');
          const historyStore = historyTx.objectStore('history');
          const historyReq = historyStore.add(historyData);
          
          historyReq.onsuccess = () => {
            log(`âœ… å†å²è®°å½•ä¿å­˜æˆåŠŸ! ID: ${historyData.id}`, 'success');
            db.close();
          };
          
          historyReq.onerror = (e) => {
            log(`âŒ å†å²è®°å½•ä¿å­˜å¤±è´¥: ${e.target.error}`, 'error');
            db.close();
          };
        };
        
        request.onerror = (e) => {
          log(`âŒ å›¾ç‰‡ä¿å­˜å¤±è´¥: ${e.target.error}`, 'error');
          db.close();
        };
        
      } catch (err) {
        log(`âŒ æµ‹è¯•å¤±è´¥: ${err.message}`, 'error');
      }
    }

    // æµ‹è¯• 4: è¯»å–å›¾ç‰‡
    async function testImageRead() {
      log('=== æµ‹è¯• 4: è¯»å–æ•°æ® ===', 'info');
      
      try {
        const db = await openDatabase();
        
        // è¯»å– images è¡¨
        const imagesTx = db.transaction(['images'], 'readonly');
        const imagesStore = imagesTx.objectStore('images');
        const imagesReq = imagesStore.getAll();
        
        imagesReq.onsuccess = () => {
          const images = imagesReq.result;
          log(`âœ… images è¡¨: ${images.length} æ¡è®°å½•`, 'success');
          images.forEach((img, i) => {
            log(`   [${i+1}] ${img.id} - ${img.size} bytes`, 'info');
          });
        };
        
        // è¯»å– history è¡¨
        const historyTx = db.transaction(['history'], 'readonly');
        const historyStore = historyTx.objectStore('history');
        const historyReq = historyStore.getAll();
        
        historyReq.onsuccess = () => {
          const history = historyReq.result;
          log(`âœ… history è¡¨: ${history.length} æ¡è®°å½•`, 'success');
          history.forEach((h, i) => {
            log(`   [${i+1}] ${h.id} - ${h.prompt}`, 'info');
          });
          db.close();
        };
        
      } catch (err) {
        log(`âŒ è¯»å–å¤±è´¥: ${err.message}`, 'error');
      }
    }

    // æ¸…ç©ºæ•°æ®åº“
    async function clearDatabase() {
      if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—?')) return;
      
      log('=== æ¸…ç©ºæ•°æ®åº“ ===', 'info');
      
      try {
        const db = await openDatabase();
        
        const tx = db.transaction(['images', 'history'], 'readwrite');
        tx.objectStore('images').clear();
        tx.objectStore('history').clear();
        
        tx.oncomplete = () => {
          log('âœ… æ•°æ®åº“å·²æ¸…ç©º', 'success');
          db.close();
        };
        
        tx.onerror = (e) => {
          log(`âŒ æ¸…ç©ºå¤±è´¥: ${e.target.error}`, 'error');
          db.close();
        };
        
      } catch (err) {
        log(`âŒ æ¸…ç©ºå¤±è´¥: ${err.message}`, 'error');
      }
    }

    // è¾…åŠ©å‡½æ•°: æ‰“å¼€æ•°æ®åº“
    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onsuccess = (e) => resolve(e.target.result);
        request.onerror = (e) => reject(e.target.error);
        
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          
          if (!db.objectStoreNames.contains('images')) {
            const imagesStore = db.createObjectStore('images', { keyPath: 'id' });
            imagesStore.createIndex('createdAt', 'createdAt', { unique: false });
          }
          
          if (!db.objectStoreNames.contains('history')) {
            const historyStore = db.createObjectStore('history', { keyPath: 'id' });
            historyStore.createIndex('timestamp', 'timestamp', { unique: false });
            historyStore.createIndex('imageId', 'imageId', { unique: false });
          }
        };
      });
    }

    // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è¿è¡Œæµ‹è¯• 1
    window.onload = () => {
      testBasicSupport();
    };
  </script>
</body>
</html>
